<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>OpenJPEG: THREAD - Mutex, conditions, threads and thread pools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenJPEG
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">THREAD - Mutex, conditions, threads and thread pools</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mutex</h2></td></tr>
<tr class="memitem:ga29120af1ce48d5ecd651795f2e427755"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a></td></tr>
<tr class="memdesc:ga29120af1ce48d5ecd651795f2e427755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a mutex.  <a href="#ga29120af1ce48d5ecd651795f2e427755">More...</a><br /></td></tr>
<tr class="separator:ga29120af1ce48d5ecd651795f2e427755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa81ea27e801a8c0cf453b256ab38e067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gaa81ea27e801a8c0cf453b256ab38e067">opj_mutex_create</a> (void)</td></tr>
<tr class="memdesc:gaa81ea27e801a8c0cf453b256ab38e067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mutex.  <a href="#gaa81ea27e801a8c0cf453b256ab38e067">More...</a><br /></td></tr>
<tr class="separator:gaa81ea27e801a8c0cf453b256ab38e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38a90b92a1d294f7e1886e36a405518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gab38a90b92a1d294f7e1886e36a405518">opj_mutex_lock</a> (<a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:gab38a90b92a1d294f7e1886e36a405518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock/acquire the mutex.  <a href="#gab38a90b92a1d294f7e1886e36a405518">More...</a><br /></td></tr>
<tr class="separator:gab38a90b92a1d294f7e1886e36a405518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1f5a5f7f7257663505af02b717272c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gacf1f5a5f7f7257663505af02b717272c">opj_mutex_unlock</a> (<a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:gacf1f5a5f7f7257663505af02b717272c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock/release the mutex.  <a href="#gacf1f5a5f7f7257663505af02b717272c">More...</a><br /></td></tr>
<tr class="separator:gacf1f5a5f7f7257663505af02b717272c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66757c34c788b873ad9acfb60a5e008b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga66757c34c788b873ad9acfb60a5e008b">opj_mutex_destroy</a> (<a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:ga66757c34c788b873ad9acfb60a5e008b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a mutex.  <a href="#ga66757c34c788b873ad9acfb60a5e008b">More...</a><br /></td></tr>
<tr class="separator:ga66757c34c788b873ad9acfb60a5e008b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Condition</h2></td></tr>
<tr class="memitem:ga439cd27c17f11fc56a911a126811fb87"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a></td></tr>
<tr class="memdesc:ga439cd27c17f11fc56a911a126811fb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a condition.  <a href="#ga439cd27c17f11fc56a911a126811fb87">More...</a><br /></td></tr>
<tr class="separator:ga439cd27c17f11fc56a911a126811fb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8a4c1ce6d9ad2dde1d293fad317522"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga7f8a4c1ce6d9ad2dde1d293fad317522">opj_cond_create</a> (void)</td></tr>
<tr class="memdesc:ga7f8a4c1ce6d9ad2dde1d293fad317522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a condition.  <a href="#ga7f8a4c1ce6d9ad2dde1d293fad317522">More...</a><br /></td></tr>
<tr class="separator:ga7f8a4c1ce6d9ad2dde1d293fad317522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6edf64f08cd0b48299800852d52245d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga6edf64f08cd0b48299800852d52245d6">opj_cond_wait</a> (<a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a> *cond, <a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> *mutex)</td></tr>
<tr class="memdesc:ga6edf64f08cd0b48299800852d52245d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the condition to be signaled.  <a href="#ga6edf64f08cd0b48299800852d52245d6">More...</a><br /></td></tr>
<tr class="separator:ga6edf64f08cd0b48299800852d52245d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3687b35d6f3c395e1156a8499d1632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga0f3687b35d6f3c395e1156a8499d1632">opj_cond_signal</a> (<a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a> *cond)</td></tr>
<tr class="memdesc:ga0f3687b35d6f3c395e1156a8499d1632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal waiting threads on a condition.  <a href="#ga0f3687b35d6f3c395e1156a8499d1632">More...</a><br /></td></tr>
<tr class="separator:ga0f3687b35d6f3c395e1156a8499d1632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba4c2356f6d070d43e5f0d5c71fdbee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gafba4c2356f6d070d43e5f0d5c71fdbee">opj_cond_destroy</a> (<a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a> *cond)</td></tr>
<tr class="memdesc:gafba4c2356f6d070d43e5f0d5c71fdbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a condition.  <a href="#gafba4c2356f6d070d43e5f0d5c71fdbee">More...</a><br /></td></tr>
<tr class="separator:gafba4c2356f6d070d43e5f0d5c71fdbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread</h2></td></tr>
<tr class="memitem:gaed72b7b75acb6eaeb620085b01ee365b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___t_h_r_e_a_d.html#gaed72b7b75acb6eaeb620085b01ee365b">opj_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gaed72b7b75acb6eaeb620085b01ee365b">opj_thread_t</a></td></tr>
<tr class="memdesc:gaed72b7b75acb6eaeb620085b01ee365b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a thread handle.  <a href="#gaed72b7b75acb6eaeb620085b01ee365b">More...</a><br /></td></tr>
<tr class="separator:gaed72b7b75acb6eaeb620085b01ee365b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f9aa8219645e0e836aaf0c453db624"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gae5f9aa8219645e0e836aaf0c453db624">opj_thread_fn</a>) (void *user_data)</td></tr>
<tr class="memdesc:gae5f9aa8219645e0e836aaf0c453db624"><td class="mdescLeft">&#160;</td><td class="mdescRight">User function to execute in a thread.  <a href="#gae5f9aa8219645e0e836aaf0c453db624">More...</a><br /></td></tr>
<tr class="separator:gae5f9aa8219645e0e836aaf0c453db624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541be683ba651c8244bde3f0d3650c92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___t_h_r_e_a_d.html#gaed72b7b75acb6eaeb620085b01ee365b">opj_thread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga541be683ba651c8244bde3f0d3650c92">opj_thread_create</a> (<a class="el" href="group___t_h_r_e_a_d.html#gae5f9aa8219645e0e836aaf0c453db624">opj_thread_fn</a> thread_fn, void *user_data)</td></tr>
<tr class="memdesc:ga541be683ba651c8244bde3f0d3650c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread.  <a href="#ga541be683ba651c8244bde3f0d3650c92">More...</a><br /></td></tr>
<tr class="separator:ga541be683ba651c8244bde3f0d3650c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49986b56da75f8609b7c940c17f713f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gad49986b56da75f8609b7c940c17f713f">opj_thread_join</a> (<a class="el" href="group___t_h_r_e_a_d.html#gaed72b7b75acb6eaeb620085b01ee365b">opj_thread_t</a> *thread)</td></tr>
<tr class="memdesc:gad49986b56da75f8609b7c940c17f713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a thread to be finished and release associated resources to the thread handle.  <a href="#gad49986b56da75f8609b7c940c17f713f">More...</a><br /></td></tr>
<tr class="separator:gad49986b56da75f8609b7c940c17f713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread local storage</h2></td></tr>
<tr class="memitem:ga9395f97b1e62916dc8b5d2ea4749f74a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structopj__tls__t.html">opj_tls_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga9395f97b1e62916dc8b5d2ea4749f74a">opj_tls_t</a></td></tr>
<tr class="memdesc:ga9395f97b1e62916dc8b5d2ea4749f74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a thread local storage.  <a href="#ga9395f97b1e62916dc8b5d2ea4749f74a">More...</a><br /></td></tr>
<tr class="separator:ga9395f97b1e62916dc8b5d2ea4749f74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f8cdfd288c8ff8963444403549ad6c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga38f8cdfd288c8ff8963444403549ad6c">opj_tls_free_func</a>) (void *value)</td></tr>
<tr class="memdesc:ga38f8cdfd288c8ff8963444403549ad6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the function used to free a TLS value.  <a href="#ga38f8cdfd288c8ff8963444403549ad6c">More...</a><br /></td></tr>
<tr class="separator:ga38f8cdfd288c8ff8963444403549ad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90caa0ff9c1e54033ef1e3010faf03a9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga90caa0ff9c1e54033ef1e3010faf03a9">opj_tls_get</a> (<a class="el" href="structopj__tls__t.html">opj_tls_t</a> *tls, int key)</td></tr>
<tr class="memdesc:ga90caa0ff9c1e54033ef1e3010faf03a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread local value corresponding to the provided key.  <a href="#ga90caa0ff9c1e54033ef1e3010faf03a9">More...</a><br /></td></tr>
<tr class="separator:ga90caa0ff9c1e54033ef1e3010faf03a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b97098aabc89f98eca8f8f7274f3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openjpeg_8h.html#abb5dad6294f4611f1925388e919b16f4">OPJ_BOOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gab1b97098aabc89f98eca8f8f7274f3e7">opj_tls_set</a> (<a class="el" href="structopj__tls__t.html">opj_tls_t</a> *tls, int key, void *value, <a class="el" href="group___t_h_r_e_a_d.html#ga38f8cdfd288c8ff8963444403549ad6c">opj_tls_free_func</a> free_func)</td></tr>
<tr class="memdesc:gab1b97098aabc89f98eca8f8f7274f3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a thread local value corresponding to the provided key.  <a href="#gab1b97098aabc89f98eca8f8f7274f3e7">More...</a><br /></td></tr>
<tr class="separator:gab1b97098aabc89f98eca8f8f7274f3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread pool</h2></td></tr>
<tr class="memitem:ga656a5e32341e7433cf6b70e53b002c5e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga656a5e32341e7433cf6b70e53b002c5e">opj_thread_pool_t</a></td></tr>
<tr class="memdesc:ga656a5e32341e7433cf6b70e53b002c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a thread pool.  <a href="#ga656a5e32341e7433cf6b70e53b002c5e">More...</a><br /></td></tr>
<tr class="separator:ga656a5e32341e7433cf6b70e53b002c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29983f3245378c30edbef61fe22913b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gaf29983f3245378c30edbef61fe22913b">opj_job_fn</a>) (void *user_data, <a class="el" href="structopj__tls__t.html">opj_tls_t</a> *tls)</td></tr>
<tr class="memdesc:gaf29983f3245378c30edbef61fe22913b"><td class="mdescLeft">&#160;</td><td class="mdescRight">User function to execute in a thread.  <a href="#gaf29983f3245378c30edbef61fe22913b">More...</a><br /></td></tr>
<tr class="separator:gaf29983f3245378c30edbef61fe22913b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a3a1b343df1168a3beb57babfa0916"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga24a3a1b343df1168a3beb57babfa0916">opj_thread_pool_create</a> (int num_threads)</td></tr>
<tr class="memdesc:ga24a3a1b343df1168a3beb57babfa0916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread pool.  <a href="#ga24a3a1b343df1168a3beb57babfa0916">More...</a><br /></td></tr>
<tr class="separator:ga24a3a1b343df1168a3beb57babfa0916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf389ecb3a583a30077fc546eef767c89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="openjpeg_8h.html#abb5dad6294f4611f1925388e919b16f4">OPJ_BOOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gaf389ecb3a583a30077fc546eef767c89">opj_thread_pool_submit_job</a> (<a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> *tp, <a class="el" href="group___t_h_r_e_a_d.html#gaf29983f3245378c30edbef61fe22913b">opj_job_fn</a> job_fn, void *user_data)</td></tr>
<tr class="memdesc:gaf389ecb3a583a30077fc546eef767c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a new job to be run by one of the thread in the thread pool.  <a href="#gaf389ecb3a583a30077fc546eef767c89">More...</a><br /></td></tr>
<tr class="separator:gaf389ecb3a583a30077fc546eef767c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ced26c80598e49bf3a964bb802130f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga0ced26c80598e49bf3a964bb802130f1">opj_thread_pool_wait_completion</a> (<a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> *tp, int max_remaining_jobs)</td></tr>
<tr class="memdesc:ga0ced26c80598e49bf3a964bb802130f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait that no more than max_remaining_jobs jobs are remaining in the queue of the thread pool.  <a href="#ga0ced26c80598e49bf3a964bb802130f1">More...</a><br /></td></tr>
<tr class="separator:ga0ced26c80598e49bf3a964bb802130f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4faef98a6b8495c63e9e5ce9cf0c3fc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#ga4faef98a6b8495c63e9e5ce9cf0c3fc3">opj_thread_pool_get_thread_count</a> (<a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> *tp)</td></tr>
<tr class="memdesc:ga4faef98a6b8495c63e9e5ce9cf0c3fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of threads associated with the thread pool.  <a href="#ga4faef98a6b8495c63e9e5ce9cf0c3fc3">More...</a><br /></td></tr>
<tr class="separator:ga4faef98a6b8495c63e9e5ce9cf0c3fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44e8b9258d0baa19e3671a382faa33e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_h_r_e_a_d.html#gae44e8b9258d0baa19e3671a382faa33e">opj_thread_pool_destroy</a> (<a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> *tp)</td></tr>
<tr class="memdesc:gae44e8b9258d0baa19e3671a382faa33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a thread pool.  <a href="#gae44e8b9258d0baa19e3671a382faa33e">More...</a><br /></td></tr>
<tr class="separator:gae44e8b9258d0baa19e3671a382faa33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga439cd27c17f11fc56a911a126811fb87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a> <a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for a condition. </p>

</div>
</div>
<a class="anchor" id="gaf29983f3245378c30edbef61fe22913b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* opj_job_fn) (void *user_data, <a class="el" href="structopj__tls__t.html">opj_tls_t</a> *tls)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User function to execute in a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_data</td><td>user data provided with <a class="el" href="group___t_h_r_e_a_d.html#ga541be683ba651c8244bde3f0d3650c92" title="Creates a new thread. ">opj_thread_create()</a> </td></tr>
    <tr><td class="paramname">tls</td><td>handle to thread local storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga29120af1ce48d5ecd651795f2e427755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> <a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for a mutex. </p>

</div>
</div>
<a class="anchor" id="gae5f9aa8219645e0e836aaf0c453db624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* opj_thread_fn) (void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User function to execute in a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_data</td><td>user data provided with <a class="el" href="group___t_h_r_e_a_d.html#ga541be683ba651c8244bde3f0d3650c92" title="Creates a new thread. ">opj_thread_create()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga656a5e32341e7433cf6b70e53b002c5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> <a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for a thread pool. </p>

</div>
</div>
<a class="anchor" id="gaed72b7b75acb6eaeb620085b01ee365b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___t_h_r_e_a_d.html#gaed72b7b75acb6eaeb620085b01ee365b">opj_thread_t</a> <a class="el" href="group___t_h_r_e_a_d.html#gaed72b7b75acb6eaeb620085b01ee365b">opj_thread_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for a thread handle. </p>

</div>
</div>
<a class="anchor" id="ga38f8cdfd288c8ff8963444403549ad6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* opj_tls_free_func) (void *value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the function used to free a TLS value. </p>

</div>
</div>
<a class="anchor" id="ga9395f97b1e62916dc8b5d2ea4749f74a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structopj__tls__t.html">opj_tls_t</a> <a class="el" href="structopj__tls__t.html">opj_tls_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type for a thread local storage. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7f8a4c1ce6d9ad2dde1d293fad317522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a>* opj_cond_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a condition. </p>
<dl class="section return"><dt>Returns</dt><dd>the condition or NULL in case of error (can for example happen if the library is built without thread support) </dd></dl>

<p>Referenced by <a class="el" href="thread_8c.html#acdca1ecb372546840fdd9d5d5badce07">opj_thread_pool_setup()</a>.</p>

</div>
</div>
<a class="anchor" id="gafba4c2356f6d070d43e5f0d5c71fdbee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opj_cond_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition to destroy. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___t_h_r_e_a_d.html#gae44e8b9258d0baa19e3671a382faa33e">opj_thread_pool_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f3687b35d6f3c395e1156a8499d1632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opj_cond_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal waiting threads on a condition. </p>
<p>One of the thread waiting with <a class="el" href="group___t_h_r_e_a_d.html#ga6edf64f08cd0b48299800852d52245d6" title="Wait for the condition to be signaled. ">opj_cond_wait()</a> will be waken up. It is strongly advised that this call is done with the mutex that is used by <a class="el" href="group___t_h_r_e_a_d.html#ga6edf64f08cd0b48299800852d52245d6" title="Wait for the condition to be signaled. ">opj_cond_wait()</a>, in a acquired state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition to signal. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___t_h_r_e_a_d.html#gae44e8b9258d0baa19e3671a382faa33e">opj_thread_pool_destroy()</a>, <a class="el" href="thread_8c.html#a57e6dc05f2283639a2ec0b6884d9691c">opj_thread_pool_get_next_job()</a>, and <a class="el" href="group___t_h_r_e_a_d.html#gaf389ecb3a583a30077fc546eef767c89">opj_thread_pool_submit_job()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6edf64f08cd0b48299800852d52245d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opj_cond_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#ga439cd27c17f11fc56a911a126811fb87">opj_cond_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the condition to be signaled. </p>
<p>The semantics is the same as the POSIX pthread_cond_wait. The provided mutex <em>must</em> be acquired before calling this function, and released afterwards. The mutex will be released by this function while it must wait for the condition and reacquired afterwards. In some particular situations, the function might return even if the condition is not signaled with <a class="el" href="group___t_h_r_e_a_d.html#ga0f3687b35d6f3c395e1156a8499d1632" title="Signal waiting threads on a condition. ">opj_cond_signal()</a>, hence the need to check with an application level mechanism.</p>
<p>Waiting thread : </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;opj_mutex_lock(mutex);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;while( !some_application_level_condition )</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    opj_cond_wait(cond, mutex);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;opj_mutex_unlock(mutex);</div>
</div><!-- fragment --><p>Signaling thread : </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;opj_mutex_lock(mutex);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;some_application_level_condition = TRUE;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;opj_cond_signal(cond);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;opj_mutex_unlock(mutex);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition to wait. </td></tr>
    <tr><td class="paramname">mutex</td><td>the mutex (in acquired state before calling this function) </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="thread_8c.html#a57e6dc05f2283639a2ec0b6884d9691c">opj_thread_pool_get_next_job()</a>, <a class="el" href="thread_8c.html#acdca1ecb372546840fdd9d5d5badce07">opj_thread_pool_setup()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gaf389ecb3a583a30077fc546eef767c89">opj_thread_pool_submit_job()</a>, and <a class="el" href="group___t_h_r_e_a_d.html#ga0ced26c80598e49bf3a964bb802130f1">opj_thread_pool_wait_completion()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa81ea27e801a8c0cf453b256ab38e067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a>* opj_mutex_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mutex. </p>
<dl class="section return"><dt>Returns</dt><dd>the mutex or NULL in case of error (can for example happen if the library is built without thread support) </dd></dl>

<p>Referenced by <a class="el" href="tcd_8c.html#a61608d1a920574e556d417a4b0e23a3a">opj_tcd_t1_decode()</a>, <a class="el" href="group___t_h_r_e_a_d.html#ga24a3a1b343df1168a3beb57babfa0916">opj_thread_pool_create()</a>, and <a class="el" href="thread_8c.html#acdca1ecb372546840fdd9d5d5badce07">opj_thread_pool_setup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga66757c34c788b873ad9acfb60a5e008b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opj_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="tcd_8c.html#a61608d1a920574e556d417a4b0e23a3a">opj_tcd_t1_decode()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gae44e8b9258d0baa19e3671a382faa33e">opj_thread_pool_destroy()</a>, and <a class="el" href="thread_8c.html#acdca1ecb372546840fdd9d5d5badce07">opj_thread_pool_setup()</a>.</p>

</div>
</div>
<a class="anchor" id="gab38a90b92a1d294f7e1886e36a405518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opj_mutex_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock/acquire the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to acquire. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___t1.html#gab90391839b2f56ca40aaae1b8748ca3c">opj_t1_decode_cblk()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gae44e8b9258d0baa19e3671a382faa33e">opj_thread_pool_destroy()</a>, <a class="el" href="thread_8c.html#a57e6dc05f2283639a2ec0b6884d9691c">opj_thread_pool_get_next_job()</a>, <a class="el" href="thread_8c.html#acdca1ecb372546840fdd9d5d5badce07">opj_thread_pool_setup()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gaf389ecb3a583a30077fc546eef767c89">opj_thread_pool_submit_job()</a>, and <a class="el" href="group___t_h_r_e_a_d.html#ga0ced26c80598e49bf3a964bb802130f1">opj_thread_pool_wait_completion()</a>.</p>

</div>
</div>
<a class="anchor" id="gacf1f5a5f7f7257663505af02b717272c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opj_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#ga29120af1ce48d5ecd651795f2e427755">opj_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock/release the mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to release. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___t1.html#gab90391839b2f56ca40aaae1b8748ca3c">opj_t1_decode_cblk()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gae44e8b9258d0baa19e3671a382faa33e">opj_thread_pool_destroy()</a>, <a class="el" href="thread_8c.html#a57e6dc05f2283639a2ec0b6884d9691c">opj_thread_pool_get_next_job()</a>, <a class="el" href="thread_8c.html#acdca1ecb372546840fdd9d5d5badce07">opj_thread_pool_setup()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gaf389ecb3a583a30077fc546eef767c89">opj_thread_pool_submit_job()</a>, and <a class="el" href="group___t_h_r_e_a_d.html#ga0ced26c80598e49bf3a964bb802130f1">opj_thread_pool_wait_completion()</a>.</p>

</div>
</div>
<a class="anchor" id="ga541be683ba651c8244bde3f0d3650c92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___t_h_r_e_a_d.html#gaed72b7b75acb6eaeb620085b01ee365b">opj_thread_t</a>* opj_thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#gae5f9aa8219645e0e836aaf0c453db624">opj_thread_fn</a>&#160;</td>
          <td class="paramname"><em>thread_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_fn</td><td>Function to run in the new thread. </td></tr>
    <tr><td class="paramname">user_data</td><td>user data provided to the thread function. Might be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a thread handle or NULL in case of failure (can for example happen if the library is built without thread support) </dd></dl>

<p>Referenced by <a class="el" href="thread_8c.html#acdca1ecb372546840fdd9d5d5badce07">opj_thread_pool_setup()</a>.</p>

</div>
</div>
<a class="anchor" id="gad49986b56da75f8609b7c940c17f713f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opj_thread_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#gaed72b7b75acb6eaeb620085b01ee365b">opj_thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a thread to be finished and release associated resources to the thread handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the thread to wait for being finished. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group___t_h_r_e_a_d.html#gae44e8b9258d0baa19e3671a382faa33e">opj_thread_pool_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga24a3a1b343df1168a3beb57babfa0916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a>* opj_thread_pool_create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread pool. </p>
<p>num_thread must nominally be &gt;= 1 to create a real thread pool. If num_threads is negative or null, then a dummy thread pool will be created. All functions operating on the thread pool will work, but job submission will be run synchronously in the calling thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>the number of threads to allocate for this thread pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a thread pool handle, or NULL in case of failure (can for example happen if the library is built without thread support) </dd></dl>

<p>References <a class="el" href="structopj__thread__pool__t.html#a818a719866334770dda95c675cb73d63">opj_thread_pool_t::mutex</a>, <a class="el" href="group___m_i_s_c.html#ga7fe6dfcb0a623dbec30daf0f48624bf7">opj_calloc()</a>, <a class="el" href="group___m_i_s_c.html#ga2bd00e2482ae36197631bde0665cfdfe">opj_free()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gaa81ea27e801a8c0cf453b256ab38e067">opj_mutex_create()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gae44e8b9258d0baa19e3671a382faa33e">opj_thread_pool_destroy()</a>, <a class="el" href="thread_8c.html#acdca1ecb372546840fdd9d5d5badce07">opj_thread_pool_setup()</a>, <a class="el" href="thread_8c.html#a28308877c7160bae4a21d2b1c8bddfe0">opj_tls_new()</a>, <a class="el" href="thread_8c.html#a72b07be38efb141bb1f0456227d233e5a837ff250630d32ebcbdec8ab7545cd23">OPJWTS_OK</a>, <a class="el" href="structopj__thread__pool__t.html#a3ee9c2691cf72fb90bf662490830b72b">opj_thread_pool_t::state</a>, and <a class="el" href="structopj__thread__pool__t.html#a401a98b276c965e0b63efaf9e1369730">opj_thread_pool_t::tls</a>.</p>

<p>Referenced by <a class="el" href="bench__dwt_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="group___j2_k.html#gad3c2b25f4d5a5f6fd4b442bc7210f6da">opj_j2k_create_compress()</a>, <a class="el" href="j2k_8h.html#ad76bb79d4d63030222ebf3dbe3fe86cf">opj_j2k_create_decompress()</a>, and <a class="el" href="group___j2_k.html#gabecf91393e6703f8be5006b19df1be22">opj_j2k_set_threads()</a>.</p>

</div>
</div>
<a class="anchor" id="gae44e8b9258d0baa19e3671a382faa33e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opj_thread_pool_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a thread pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>the thread pool handle. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structopj__worker__thread__t.html#a8e7cdff9dab59b5be9ed46436437f28a">opj_worker_thread_t::cond</a>, <a class="el" href="structopj__thread__pool__t.html#a19d0f595937228552fe62c69cb2f6c44">opj_thread_pool_t::cond</a>, <a class="el" href="structopj__worker__thread__t.html#a2ba43db98feae7de2aaed97d08ec55ce">opj_worker_thread_t::mutex</a>, <a class="el" href="structopj__thread__pool__t.html#a818a719866334770dda95c675cb73d63">opj_thread_pool_t::mutex</a>, <a class="el" href="structopj__worker__thread__list__t.html#ac0a28fac91ec02c49898229a1122aa67">opj_worker_thread_list_t::next</a>, <a class="el" href="group___t_h_r_e_a_d.html#gafba4c2356f6d070d43e5f0d5c71fdbee">opj_cond_destroy()</a>, <a class="el" href="group___t_h_r_e_a_d.html#ga0f3687b35d6f3c395e1156a8499d1632">opj_cond_signal()</a>, <a class="el" href="group___m_i_s_c.html#ga2bd00e2482ae36197631bde0665cfdfe">opj_free()</a>, <a class="el" href="group___t_h_r_e_a_d.html#ga66757c34c788b873ad9acfb60a5e008b">opj_mutex_destroy()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gab38a90b92a1d294f7e1886e36a405518">opj_mutex_lock()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gacf1f5a5f7f7257663505af02b717272c">opj_mutex_unlock()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gad49986b56da75f8609b7c940c17f713f">opj_thread_join()</a>, <a class="el" href="group___t_h_r_e_a_d.html#ga0ced26c80598e49bf3a964bb802130f1">opj_thread_pool_wait_completion()</a>, <a class="el" href="thread_8c.html#a8f4ee11fc0faa44d49f2c341cbf3dc79">opj_tls_destroy()</a>, <a class="el" href="thread_8c.html#a72b07be38efb141bb1f0456227d233e5a3e1ea93366aedb1abcd0498bf72db68a">OPJWTS_STOP</a>, <a class="el" href="structopj__thread__pool__t.html#a3ee9c2691cf72fb90bf662490830b72b">opj_thread_pool_t::state</a>, <a class="el" href="structopj__worker__thread__t.html#a7ef79b815efbb4ff8d49f3ed4f677073">opj_worker_thread_t::thread</a>, <a class="el" href="structopj__thread__pool__t.html#a401a98b276c965e0b63efaf9e1369730">opj_thread_pool_t::tls</a>, <a class="el" href="structopj__thread__pool__t.html#a50c4caa87ba2a6767d909898cc92b37a">opj_thread_pool_t::waiting_worker_thread_list</a>, <a class="el" href="structopj__thread__pool__t.html#adb012d263904a4f62812ed7d30b0a47e">opj_thread_pool_t::worker_threads</a>, and <a class="el" href="structopj__thread__pool__t.html#a43fd14e3ba8409a0fac589a6dd4e7ee1">opj_thread_pool_t::worker_threads_count</a>.</p>

<p>Referenced by <a class="el" href="bench__dwt_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>, <a class="el" href="j2k_8h.html#a5c4508543b134e726107308b6463528e">opj_j2k_destroy()</a>, <a class="el" href="group___j2_k.html#gabecf91393e6703f8be5006b19df1be22">opj_j2k_set_threads()</a>, and <a class="el" href="group___t_h_r_e_a_d.html#ga24a3a1b343df1168a3beb57babfa0916">opj_thread_pool_create()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4faef98a6b8495c63e9e5ce9cf0c3fc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opj_thread_pool_get_thread_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> *&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of threads associated with the thread pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>the thread pool handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of threads associated with the thread pool. </dd></dl>

<p>References <a class="el" href="structopj__thread__pool__t.html#a43fd14e3ba8409a0fac589a6dd4e7ee1">opj_thread_pool_t::worker_threads_count</a>.</p>

<p>Referenced by <a class="el" href="group___d_w_t.html#ga473550255363b8acb0c9b10a6dbac434">opj_dwt_decode_tile()</a>, and <a class="el" href="group___t1.html#ga20cf3c3ce3f470e6311e96bf6e365cb0">opj_t1_decode_cblks()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf389ecb3a583a30077fc546eef767c89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openjpeg_8h.html#abb5dad6294f4611f1925388e919b16f4">OPJ_BOOL</a> opj_thread_pool_submit_job </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#gaf29983f3245378c30edbef61fe22913b">opj_job_fn</a>&#160;</td>
          <td class="paramname"><em>job_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a new job to be run by one of the thread in the thread pool. </p>
<p>The job ( thread_fn, user_data ) will be added in the queue of jobs managed by the thread pool, and run by the first thread that is no longer busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>the thread pool handle. </td></tr>
    <tr><td class="paramname">job_fn</td><td>Function to run. Must not be NULL. </td></tr>
    <tr><td class="paramname">user_data</td><td>User data provided to thread_fn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OPJ_TRUE if the job was successfully submitted. </dd></dl>

<p>References <a class="el" href="structopj__worker__thread__t.html#a8e7cdff9dab59b5be9ed46436437f28a">opj_worker_thread_t::cond</a>, <a class="el" href="structopj__thread__pool__t.html#a19d0f595937228552fe62c69cb2f6c44">opj_thread_pool_t::cond</a>, <a class="el" href="structopj__job__list__t.html#a84b556f2984f8f7a4b38cb0a075d3d1e">opj_job_list_t::job</a>, <a class="el" href="structopj__worker__thread__job__t.html#ab9dc542136b4596b711e3be011abdd4d">opj_worker_thread_job_t::job_fn</a>, <a class="el" href="structopj__thread__pool__t.html#aff15e4a4599fc823762f8d3c28d8353d">opj_thread_pool_t::job_queue</a>, <a class="el" href="structopj__worker__thread__t.html#a6cf93c9b46f4b51b9247a179f49fc796">opj_worker_thread_t::marked_as_waiting</a>, <a class="el" href="structopj__worker__thread__t.html#a2ba43db98feae7de2aaed97d08ec55ce">opj_worker_thread_t::mutex</a>, <a class="el" href="structopj__thread__pool__t.html#a818a719866334770dda95c675cb73d63">opj_thread_pool_t::mutex</a>, <a class="el" href="structopj__job__list__t.html#a27d174268d6050639a4032780172d87f">opj_job_list_t::next</a>, <a class="el" href="structopj__worker__thread__list__t.html#ac0a28fac91ec02c49898229a1122aa67">opj_worker_thread_list_t::next</a>, <a class="el" href="group___t_h_r_e_a_d.html#ga0f3687b35d6f3c395e1156a8499d1632">opj_cond_signal()</a>, <a class="el" href="group___t_h_r_e_a_d.html#ga6edf64f08cd0b48299800852d52245d6">opj_cond_wait()</a>, <a class="el" href="openjpeg_8h.html#ac672bfd7db39c609e828acb07a321964">OPJ_FALSE</a>, <a class="el" href="group___m_i_s_c.html#ga2bd00e2482ae36197631bde0665cfdfe">opj_free()</a>, <a class="el" href="group___m_i_s_c.html#ga49c70931cbed786f6eef5f095bcb2917">opj_malloc()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gab38a90b92a1d294f7e1886e36a405518">opj_mutex_lock()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gacf1f5a5f7f7257663505af02b717272c">opj_mutex_unlock()</a>, <a class="el" href="openjpeg_8h.html#a04830036d767cba56cbf5ae5bdc481d3">OPJ_TRUE</a>, <a class="el" href="structopj__thread__pool__t.html#ad84a2e09419498cf81c8994f0441b131">opj_thread_pool_t::pending_jobs_count</a>, <a class="el" href="structopj__thread__pool__t.html#ae68571d1cf6eae577c75df49c2827438">opj_thread_pool_t::signaling_threshold</a>, <a class="el" href="structopj__thread__pool__t.html#a401a98b276c965e0b63efaf9e1369730">opj_thread_pool_t::tls</a>, <a class="el" href="structopj__worker__thread__job__t.html#a89f225764ee25dabc5e374ed277cd286">opj_worker_thread_job_t::user_data</a>, <a class="el" href="structopj__thread__pool__t.html#abad6b35fb3cc6cd8aaaf523de9a4a187">opj_thread_pool_t::waiting_worker_thread_count</a>, <a class="el" href="structopj__thread__pool__t.html#a50c4caa87ba2a6767d909898cc92b37a">opj_thread_pool_t::waiting_worker_thread_list</a>, <a class="el" href="structopj__worker__thread__list__t.html#af36b36ba7fc3ab5febe59faf30c86c7f">opj_worker_thread_list_t::worker_thread</a>, and <a class="el" href="structopj__thread__pool__t.html#a43fd14e3ba8409a0fac589a6dd4e7ee1">opj_thread_pool_t::worker_threads_count</a>.</p>

<p>Referenced by <a class="el" href="group___d_w_t.html#ga473550255363b8acb0c9b10a6dbac434">opj_dwt_decode_tile()</a>, and <a class="el" href="group___t1.html#ga20cf3c3ce3f470e6311e96bf6e365cb0">opj_t1_decode_cblks()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ced26c80598e49bf3a964bb802130f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opj_thread_pool_wait_completion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopj__thread__pool__t.html">opj_thread_pool_t</a> *&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_remaining_jobs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait that no more than max_remaining_jobs jobs are remaining in the queue of the thread pool. </p>
<p>The aim of this function is to avoid submitting too many jobs while the thread pool cannot cope fast enough with them, which would result potentially in out-of-memory situations with too many job descriptions being queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>the thread pool handle </td></tr>
    <tr><td class="paramname">max_remaining_jobs</td><td>maximum number of jobs allowed to be queued without waiting. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structopj__thread__pool__t.html#a19d0f595937228552fe62c69cb2f6c44">opj_thread_pool_t::cond</a>, <a class="el" href="structopj__thread__pool__t.html#a818a719866334770dda95c675cb73d63">opj_thread_pool_t::mutex</a>, <a class="el" href="group___t_h_r_e_a_d.html#ga6edf64f08cd0b48299800852d52245d6">opj_cond_wait()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gab38a90b92a1d294f7e1886e36a405518">opj_mutex_lock()</a>, <a class="el" href="group___t_h_r_e_a_d.html#gacf1f5a5f7f7257663505af02b717272c">opj_mutex_unlock()</a>, <a class="el" href="structopj__thread__pool__t.html#ad84a2e09419498cf81c8994f0441b131">opj_thread_pool_t::pending_jobs_count</a>, and <a class="el" href="structopj__thread__pool__t.html#ae68571d1cf6eae577c75df49c2827438">opj_thread_pool_t::signaling_threshold</a>.</p>

<p>Referenced by <a class="el" href="group___d_w_t.html#ga473550255363b8acb0c9b10a6dbac434">opj_dwt_decode_tile()</a>, <a class="el" href="tcd_8c.html#a61608d1a920574e556d417a4b0e23a3a">opj_tcd_t1_decode()</a>, and <a class="el" href="group___t_h_r_e_a_d.html#gae44e8b9258d0baa19e3671a382faa33e">opj_thread_pool_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga90caa0ff9c1e54033ef1e3010faf03a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* opj_tls_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopj__tls__t.html">opj_tls_t</a> *&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a thread local value corresponding to the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>thread local storage handle </td></tr>
    <tr><td class="paramname">key</td><td>key whose value to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value associated with the key, or NULL is missing. </dd></dl>

<p>References <a class="el" href="structopj__tls__key__val__t.html#ad6fb434626095a18d07e1f617c1caa4a">opj_tls_key_val_t::key</a>, <a class="el" href="structopj__tls__t.html#adfd2bdbeb80b7f067288709b3c3fc1aa">opj_tls_t::key_val</a>, <a class="el" href="structopj__tls__t.html#ae2c441fd26b7ae11a86163d5bebb4d2e">opj_tls_t::key_val_count</a>, and <a class="el" href="structopj__tls__key__val__t.html#a58ca4c6fe1d0342a77b89bb240a6f549">opj_tls_key_val_t::value</a>.</p>

<p>Referenced by <a class="el" href="t1_8c.html#a4f37cf7aca8eb1313fe5bc320c85ad55">opj_t1_clbl_decode_processor()</a>.</p>

</div>
</div>
<a class="anchor" id="gab1b97098aabc89f98eca8f8f7274f3e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="openjpeg_8h.html#abb5dad6294f4611f1925388e919b16f4">OPJ_BOOL</a> opj_tls_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopj__tls__t.html">opj_tls_t</a> *&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_h_r_e_a_d.html#ga38f8cdfd288c8ff8963444403549ad6c">opj_tls_free_func</a>&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a thread local value corresponding to the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tls</td><td>thread local storage handle </td></tr>
    <tr><td class="paramname">key</td><td>key whose value to set. </td></tr>
    <tr><td class="paramname">value</td><td>value to set (may be NULL). </td></tr>
    <tr><td class="paramname">free_func</td><td>function to call currently installed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OPJ_TRUE if successful. </dd></dl>

<p>References <a class="el" href="structopj__tls__key__val__t.html#ad6fb434626095a18d07e1f617c1caa4a">opj_tls_key_val_t::key</a>, <a class="el" href="structopj__tls__t.html#adfd2bdbeb80b7f067288709b3c3fc1aa">opj_tls_t::key_val</a>, <a class="el" href="structopj__tls__t.html#ae2c441fd26b7ae11a86163d5bebb4d2e">opj_tls_t::key_val_count</a>, <a class="el" href="openjpeg_8h.html#ac672bfd7db39c609e828acb07a321964">OPJ_FALSE</a>, <a class="el" href="structopj__tls__key__val__t.html#a3a1ff12d54b55c7d3e30f31b10ad261e">opj_tls_key_val_t::opj_free_func</a>, <a class="el" href="group___m_i_s_c.html#ga95862b2a456efdc436c61beba816fb25">opj_realloc()</a>, <a class="el" href="openjpeg_8h.html#a04830036d767cba56cbf5ae5bdc481d3">OPJ_TRUE</a>, and <a class="el" href="structopj__tls__key__val__t.html#a58ca4c6fe1d0342a77b89bb240a6f549">opj_tls_key_val_t::value</a>.</p>

<p>Referenced by <a class="el" href="t1_8c.html#a4f37cf7aca8eb1313fe5bc320c85ad55">opj_t1_clbl_decode_processor()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
